# ASM

- [1. x86](#1-x86)
  - [1.1. 语法](#11-语法)
  - [1.2. 寄存器](#12-寄存器)
  - [1.3. 操作数](#13-操作数)
  - [1.4. 指令](#14-指令)
- [2. arm](#2-arm)
  - [2.1. 寄存器](#21-寄存器)
  - [2.2. 操作数](#22-操作数)
  - [2.3. 指令](#23-指令)

点开头的都是指导汇编器和链接器的伪命令

## 1. x86

### 1.1. 语法

分为 AT&T（常见）和 intel 语法

objdump、gcc 生成 .s 文件应该都是 AT&T 语法

### 1.2. 寄存器

- `%rip` 程序计数器 PC，指向下一条指令
- 一般有 16 个通用寄存器，`%al %ax %eax %rax` 分别是 8, 16, 32, 64 位，`%r8b %r8w %r8d %r8` 同理
  - `%rax` 返回值
  - `%rbx` 调用函数前后需保证不变
  - `%rcx` 第 4 个参数
  - `%rdx` 第 3 个参数
  - `%rsi` 第 2 个参数
  - `%rdi` 第 1 个参数
  - `%rbp` 调用函数前后需保证不变，帧指针
  - `%rsp` 栈指针
  - `%r8` 第 5 个参数
  - `%r9` 第 6 个参数
  - `%r10` 随意修改
  - `%r11` 随意修改
  - `%r12` 调用函数前后需保证不变
  - `%r13` 调用函数前后需保证不变
  - `%r14` 调用函数前后需保证不变
  - `%r15` 调用函数前后需保证不变
- 段寄存器？
- 标志寄存器

### 1.3. 操作数

AT&T 语法

- `$0x123` 立即数
- `0x123` 绝对寻址
- `(%rax, %rcx)` a + c
- `9(%rax, %rcx)` a + c + 9
- `(%rax, %rcx, 4)` a + c * 4
- `9(%rax, %rcx, 4)` a + c * 4 + 9

intel 语法

- `0x123` 立即数
- `[eax - 1]` a - 1

### 1.4. 指令

AT&T 语法

- 指令后缀 `b w l q` 分别是 8, 16, 32, 64 位
- 运算结果存最后一个操作数
- `movq %rax, %rbx`：`b = a`
  - movl 会把目的寄存器的高 4 字节置 0
- `pushq %rax`：`rsp -= 8, *rsp = a`
- `popq %rax`：`a = *rsp, rsp += 8`
- sar 有符号右移，shr 无符合右移

intel 语法

- `byte, word, dword, qword` 后面跟 ptr，分别是 8, 16, 32, 64 位的寻址
- 运算结果存第一个操作数
- `mov eax, 0`：`a = 0`

## 2. arm

### 2.1. 寄存器

31 个通用寄存器 `Xn/Wn`

- `X0..X30` 64bit `W0..W30` 32bit
- X0 返回值 / 参数
- X1..7 参数
- X8 返回值
- FP / X29 栈帧（栈底）
- LR / X30 返回地址

特殊寄存器

- SP/WSP 栈指针
- CPSR 状态寄存器
  - N 负数
  - Z 零
  - C 无符号溢出
  - V 有符号溢出
- PC 程序计数器，不可直接访问
- ZR/WZR 零寄存器

### 2.2. 操作数

- `#233 #0xF #-1`：立即数
- `[X1, #1]`：访问 X1 + 1

### 2.3. 指令

- `MOV X0, X1`：X0 = X1
- `ADD X0, X1, X2`：X0 = X1 + X2
- `RET`：返回（可能有一个操作数，一般是 X30）
